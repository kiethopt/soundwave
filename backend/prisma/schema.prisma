generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String    @id @default(cuid())
  email                String    @unique
  username             String?   @unique
  password             String
  name                 String?
  avatar               String?
  role                 Role      @default(USER)
  isActive             Boolean   @default(true)
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  lastLoginAt          DateTime?
  passwordResetToken   String?
  passwordResetExpires DateTime?

  // Artist specific fields
  artistProfile           ArtistProfile?
  bio                     String?        @db.Text
  isVerified              Boolean        @default(false)
  verificationRequestedAt DateTime?
  verifiedAt              DateTime?
  monthlyListeners        Int            @default(0) @db.Integer

  // Relations
  albums          Album[]
  tracks          Track[]
  history         History[]
  playlists       Playlist[]
  followedArtists UserFollowArtist[] @relation("Follower")
  followers       UserFollowArtist[] @relation("Following")
  notifications   Notification[]
  likedTracks     UserLikeTrack[]
  events          Event[]
  trackArtist     TrackArtist[]

  @@unique([email, username])
  @@index([email])
  @@index([username])
  @@index([role])
  @@index([isActive])
  @@index([verifiedAt])
  @@index([createdAt])
  @@map("users")
}

model ArtistProfile {
  id               String   @id @default(cuid())
  artistName       String   @unique
  bio              String?  @db.Text
  socialMediaLinks Json?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Quan hệ one-to-one với User
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique

  // Quan hệ many-to-many với Genre qua bảng trung gian ArtistGenre
  genres      ArtistGenre[]
  TrackArtist TrackArtist[]

  @@index([artistName])
  @@map("artist_profiles")
}

model ArtistGenre {
  id              String   @id @default(cuid())
  artistProfileId String
  genreId         String
  createdAt       DateTime @default(now())

  // Quan hệ many-to-one với ArtistProfile
  artistProfile ArtistProfile @relation(fields: [artistProfileId], references: [id], onDelete: Cascade) // Giữ onDelete ở bảng trung gian

  // Quan hệ many-to-one với Genre
  genre Genre @relation(fields: [genreId], references: [id], onDelete: Cascade) // Giữ onDelete ở bảng trung gian

  @@unique([artistProfileId, genreId])
  @@map("artist_genre")
}

model Album {
  id          String    @id @default(cuid())
  title       String
  coverUrl    String?
  releaseDate DateTime
  trackCount  Int       @db.Integer
  duration    Int       @default(0) @db.Integer
  type        AlbumType @default(ALBUM)
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  artist   User         @relation(fields: [artistId], references: [id], onDelete: Cascade)
  artistId String
  tracks   Track[]
  genres   AlbumGenre[]

  @@unique([title, artistId])
  @@index([title])
  @@index([artistId])
  @@index([releaseDate])
  @@index([isActive])
  @@index([createdAt])
  @@map("albums")
}

model Track {
  id          String    @id @default(cuid())
  title       String
  duration    Int       @default(0) @db.Integer
  releaseDate DateTime
  trackNumber Int?      @db.Integer
  coverUrl    String?
  audioUrl    String
  playCount   Int       @default(0) @db.Integer
  type        AlbumType @default(SINGLE)
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  artist          User            @relation(fields: [artistId], references: [id], onDelete: Cascade)
  artistId        String
  featuredArtists TrackArtist[]
  album           Album?          @relation(fields: [albumId], references: [id], onDelete: Cascade)
  albumId         String?
  genres          TrackGenre[]
  playlists       PlaylistTrack[]
  history         History[]
  likedBy         UserLikeTrack[]

  @@unique([title, artistId])
  @@index([title])
  @@index([artistId])
  @@index([albumId])
  @@index([playCount])
  @@index([releaseDate])
  @@index([isActive])
  @@index([createdAt])
  @@map("tracks")
}

model History {
  id        String      @id @default(cuid())
  type      HistoryType
  query     String?
  duration  Int?        @db.Integer
  completed Boolean?
  playCount Int?        @db.Integer
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  track   Track?  @relation(fields: [trackId], references: [id], onDelete: Cascade)
  trackId String?
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId  String

  @@unique([userId, trackId, type])
  @@index([userId])
  @@index([type])
  @@index([trackId])
  @@index([createdAt])
  @@index([playCount])
  @@map("histories")
}

model Playlist {
  id            String          @id @default(cuid())
  name          String
  description   String?
  coverUrl      String?
  privacy       PlaylistPrivacy @default(PRIVATE)
  type          PlaylistType    @default(NORMAL)
  isAIGenerated Boolean         @default(false)
  totalTracks   Int             @default(0) @db.Integer
  totalDuration Int             @default(0) @db.Integer
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  user   User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
  tracks PlaylistTrack[]

  @@unique([userId, type])
  @@unique([name, userId])
  @@index([userId])
  @@index([privacy])
  @@map("playlists")
}

model Genre {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  albums         AlbumGenre[]
  tracks         TrackGenre[]
  artistProfiles ArtistGenre[]

  @@index([name])
  @@map("genres")
}

model Notification {
  id        String           @id @default(cuid())
  type      NotificationType
  message   String
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  @@index([userId])
  @@index([createdAt])
  @@map("notifications")
}

model Event {
  id          String   @id @default(cuid())
  title       String
  description String?
  location    String
  startDate   DateTime
  endDate     DateTime
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  artist   User   @relation(fields: [artistId], references: [id], onDelete: Cascade)
  artistId String

  @@unique([title, artistId])
  @@index([artistId])
  @@index([startDate])
  @@index([endDate])
  @@index([isActive])
  @@index([createdAt])
  @@map("events")
}

// Bảng trung gian

model UserFollowArtist {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower  User @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade) // Giữ onDelete ở bảng trung gian
  following User @relation("Following", fields: [followingId], references: [id], onDelete: Cascade) // Giữ onDelete ở bảng trung gian

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("user_follow_artist")
}

model AlbumGenre {
  id        String   @id @default(cuid())
  albumId   String
  genreId   String
  createdAt DateTime @default(now())

  album Album @relation(fields: [albumId], references: [id], onDelete: Cascade) // Giữ onDelete ở bảng trung gian
  genre Genre @relation(fields: [genreId], references: [id], onDelete: Cascade) // Giữ onDelete ở bảng trung gian

  @@unique([albumId, genreId])
  @@index([albumId])
  @@index([genreId])
  @@map("album_genre")
}

model TrackGenre {
  id        String   @id @default(cuid())
  trackId   String
  genreId   String
  createdAt DateTime @default(now())

  track Track @relation(fields: [trackId], references: [id], onDelete: Cascade)
  genre Genre @relation(fields: [genreId], references: [id], onDelete: Cascade)

  @@unique([trackId, genreId])
  @@index([trackId])
  @@index([genreId])
  @@map("track_genre")
}

model TrackArtist {
  id              String   @id @default(cuid())
  trackId         String
  artistProfileId String
  createdAt       DateTime @default(now())

  track         Track         @relation(fields: [trackId], references: [id], onDelete: Cascade)
  artistProfile ArtistProfile @relation(fields: [artistProfileId], references: [id], onDelete: Cascade)
  User          User?         @relation(fields: [userId], references: [id])
  userId        String?

  @@unique([trackId, artistProfileId])
  @@index([trackId])
  @@index([artistProfileId])
  @@map("track_artist")
}

model PlaylistTrack {
  id         String   @id @default(cuid())
  playlistId String
  trackId    String
  addedAt    DateTime @default(now())
  trackOrder Int      @db.Integer

  // Relations
  playlist Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade) // Giữ onDelete ở bảng trung gian
  track    Track    @relation(fields: [trackId], references: [id], onDelete: Cascade) // Giữ onDelete ở bảng trung gian

  @@unique([playlistId, trackId])
  @@index([playlistId])
  @@index([trackId])
  @@map("playlist_track")
}

model UserLikeTrack {
  id        String   @id @default(cuid())
  userId    String
  trackId   String
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade) // Giữ onDelete ở bảng trung gian
  track Track @relation(fields: [trackId], references: [id], onDelete: Cascade) // Giữ onDelete ở bảng trung gian

  @@unique([userId, trackId])
  @@index([userId])
  @@index([trackId])
  @@map("user_like_track")
}

enum Role {
  USER
  ARTIST
  ADMIN
}

enum AlbumType {
  ALBUM
  EP
  SINGLE
}

enum HistoryType {
  SEARCH
  PLAY
}

enum PlaylistPrivacy {
  PUBLIC
  PRIVATE
}

enum PlaylistType {
  FAVORITE
  NORMAL
}

enum NotificationType {
  NEW_TRACK
  NEW_ALBUM
  EVENT
  FOLLOW
}
